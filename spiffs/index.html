<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Device Images • Manager</title>
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #12151a;
      --panel-2: #171b22;
      --text: #e8eef6;
      --muted: #9aa6b2;
      --primary: #4da3ff;
      --primary-2: #2b84f6;
      --accent: #7af0c9;
      --danger: #ff6b6b;
      --radius: 16px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f8fb;
        --panel: #ffffff;
        --panel-2: #f5f7fb;
        --text: #0f1720;
        --muted: #4b5563;
        --primary: #2563eb;
        --primary-2: #1d4ed8;
        --accent: #0ea5e9;
      }
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, var(--bg), #0a0c10 60%);
      color: var(--text);
    }
    header {
      position: sticky; top: 0; z-index: 20; backdrop-filter: blur(8px);
      background: linear-gradient(180deg, rgba(0,0,0,.4), rgba(0,0,0,.0));
      padding: 18px 16px 8px 16px; text-align: center;
    }
    .title {
      font-weight: 700; letter-spacing: .3px; margin: 0; font-size: clamp(18px, 3.8vw, 26px);
    }
    .sub { margin-top: 4px; color: var(--muted); font-size: 13px; }

    .container { max-width: 1100px; margin: 20px auto 36px; padding: 0 16px; }

    .panel { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border-radius: var(--radius); box-shadow: var(--shadow); }

    .grid {
      display: grid; gap: 14px; grid-template-columns: repeat( auto-fill, minmax(140px, 1fr) );
    }
    .card { position: relative; overflow: hidden; border-radius: 14px; background: #0e1116; border: 1px solid rgba(255,255,255,.06); }
    .thumb { width: 100%; aspect-ratio: 1/1; object-fit: cover; display: block; background: #0b0e13; }
    .card .meta { position:absolute; inset:auto 6px 6px 6px; display:flex; justify-content:space-between; align-items:center; }
    .badge { font-size: 11px; padding: 3px 8px; border-radius: 999px; background: rgba(0,0,0,.45); color: #cfd8e3; backdrop-filter: blur(4px); }
    .btn {
      display: inline-flex; align-items: center; gap: 8px; border: 0; border-radius: 12px; padding: 10px 14px; cursor: pointer; font-weight: 600;
      color: white; background: linear-gradient(180deg, var(--primary), var(--primary-2));
      box-shadow: 0 6px 16px rgba(37,99,235,.35);
    }
    .btn:disabled { opacity: .6; cursor: not-allowed; filter: grayscale(.6); }
    .btn.secondary { background: #222935; color: #dbe6f5; box-shadow: none; border: 1px solid rgba(255,255,255,.08); }
    .btn.danger { background: linear-gradient(180deg, #ff6b6b, #ef4444); box-shadow: 0 6px 16px rgba(239,68,68,.35); }

    .toolbar { display:flex; flex-wrap: wrap; gap: 10px; align-items:center; justify-content: space-between; padding: 14px; border-bottom: 1px solid rgba(255,255,255,.06); }

    .uploader { display:grid; grid-template-columns: 1fr; gap: 16px; padding: 16px; }
    @media(min-width: 860px){ .uploader { grid-template-columns: 1fr 1fr; } }

    .drop { position: relative; border: 1.5px dashed rgba(255,255,255,.2); border-radius: 14px; min-height: 180px; display:grid; place-items:center; text-align:center; padding: 18px; }
    .drop input[type=file]{ position:absolute; inset:0; opacity:0; cursor:pointer; }
    .drop .hint { color: var(--muted); font-size: 13px; }

    .crop-wrap { display:grid; gap: 10px; }
    .canvas-box { position: relative; width: 100%; aspect-ratio: 1/1; border-radius: 14px; overflow: hidden; background:#0b0e13; border: 1px solid rgba(255,255,255,.08); }
    canvas { display:block; width:100%; height:100%; }

    .controls { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items:center; }
    .controls .row { display:flex; gap:10px; align-items:center; }
    .controls label { color: var(--muted); font-size: 12px; width: 92px; }
    .slider { appearance: none; width:100%; height: 4px; border-radius:999px; background: rgba(255,255,255,.15); outline:none; }
    .slider::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:18px; height:18px; border-radius:50%; background: var(--accent); border: 2px solid #fff3; }
    .slider::-moz-range-thumb { width:18px; height:18px; border-radius:50%; background: var(--accent); border: 2px solid #fff3; }

    .toast { position: fixed; right: 16px; bottom: 16px; background:#10141b; border:1px solid rgba(255,255,255,.08); color:#dbe6f5; padding: 10px 12px; border-radius: 10px; box-shadow: var(--shadow); display:none; }

    .skeleton { background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.10), rgba(255,255,255,.06)); background-size: 200% 100%; animation: skl 1.2s infinite linear; }
    @keyframes skl { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }

    .center { display:flex; align-items:center; justify-content:center; gap:10px; }
    .muted { color: var(--muted); }
    .hidden { display:none !important; }
  .settings-grid { display:grid; grid-template-columns: 1fr; gap: 12px; padding: 16px; }
  .field { display:flex; align-items:center; gap:12px; }
  .field label { width: 200px; font-size: 13px; color: var(--muted); }
  .text { background: #0e131b; color: var(--text); border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius: 10px; outline: none; width: 140px; }
  .row-actions { display:flex; gap:10px; align-items:center; }
  </style>
</head>
<body>
  <header>
    <h1 class="title">Device Images Manager</h1>
    <div class="sub">Browse current images on the device • Upload a new one • Crop to a precise square (mouse wheel to zoom)</div>
  </header>

  <div class="container">
    <!-- GALLERY PANEL -->
    <section class="panel" id="galleryPanel">
      <div class="toolbar">
        <div class="center">
          <strong>Current Images</strong>
          <span class="muted" id="countLabel"></span>
        </div>
        <div class="center">
          <button class="btn secondary" id="refreshBtn" title="Reload list">⟳ Refresh</button>
        </div>
      </div>
      <div style="padding: 16px;">
        <div class="grid" id="galleryGrid"></div>
        <div id="emptyState" class="center muted" style="padding: 30px; display:none;">No images found on the device.</div>
      </div>
    </section>

    <div style="height: 18px;"></div>

    <!-- SETTINGS PANEL -->
    <section class="panel" id="settingsPanel">
      <div class="toolbar"><strong>Settings</strong><span class="muted" id="settingsInfo"></span></div>
      <div class="settings-grid">
        <div class="field">
          <label for="secInput">Seconds per image</label>
          <input id="secInput" class="text" type="number" min="1" max="3600" step="1" value="10" />
          <span class="muted">1–3600</span>
        </div>
        <div class="row-actions">
          <button id="saveSettingsBtn" class="btn">Save</button>
          <button id="reloadSettingsBtn" class="btn secondary">Reload</button>
        </div>
      </div>
    </section>

    <!-- UPLOADER + CROPPER PANEL -->
    <section class="panel">
      <div class="toolbar"><strong>Upload & Crop</strong><span class="muted" id="fileInfo"></span></div>
      <div class="uploader">
        <div>
          <div class="drop" id="dropZone">
            <input type="file" id="fileInput" accept="image/*" />
            <div>
              <div style="font-weight:700; margin-bottom:6px;">Drop image here or click to choose</div>
              <div class="hint">Supported: JPG / PNG / WEBP • The square cropper appears after you select a file.</div>
            </div>
          </div>
          <div style="height: 12px;"></div>
          <div class="center"><button class="btn" id="uploadBtn" disabled>Crop & Upload</button><button class="btn secondary" id="resetBtn" disabled>Reset</button></div>
        </div>
        <div class="crop-wrap">
          <div class="canvas-box" id="canvasBox">
            <canvas id="cropCanvas" width="900" height="900" aria-label="Crop preview"></canvas>
          </div>
          <div class="controls">
            <div class="row"><label for="zoomRange">Zoom</label><input id="zoomRange" type="range" min="1" max="10" step="0.001" value="1" class="slider" disabled></div>
            <div class="row"><label for="outSize">Export</label><input id="outSize" type="range" min="128" max="2048" step="64" value="128" class="slider"><span class="muted" id="outSizeLabel">128×128</span></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Optional JSON config override; if present, these values replace defaults.
       Example:
       <script id="api-config" type="application/json">{
         "list": "/api/images",
         "upload": "/api/upload",
         "delete": "/api/images/"  
       }</script>
  -->
  <script id="api-config" type="application/json"></script>

  <script>
    // =========================
    //  CONFIGURE ENDPOINTS HERE
    // =========================
    const API = (() => {
      const defaults = {
        /** GET list endpoint. Expected responses handled:
         *  (A) { images: [{ id, url, name?, thumb? }, ...] }
         *  (B) [ { id, url }, ... ]
         *  (C) [ "url1", "url2", ... ]
         */
        list: "/api/list",
        /** PUT with blob body. Returns 200/201 on success. */
        upload: "/api/upload/",
        /** DELETE <delete><name> */
        delete: "/api/delete/"
      };
      try {
        const cfgTag = document.getElementById('api-config');
        if (cfgTag && cfgTag.textContent.trim()) {
          const overrides = JSON.parse(cfgTag.textContent);
          return Object.assign(defaults, overrides || {});
        }
      } catch (e) { console.warn('Invalid api-config JSON', e); }
      return defaults;
    })();

    // Small helpers
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const toast = (msg, ms=2200) => { const t = $('#toast'); t.textContent = msg; t.style.display='block'; clearTimeout(window.__toast); window.__toast = setTimeout(()=> t.style.display='none', ms); };

    // --------- Gallery ---------
    const galleryGrid = $('#galleryGrid');
    const countLabel = $('#countLabel');
    const emptyState = $('#emptyState');
    const refreshBtn = $('#refreshBtn');

    function normalizeList(json) {
      if (!json) return [];
      if (Array.isArray(json)) {
        if (json.length && typeof json[0] === 'string') return json.map((url, i) => ({ id: i.toString(), url }));
        return json.map((x, i) => ({ id: x.id ?? i.toString(), url: x.url ?? x.href ?? x.path ?? '', name: x.name ?? null, thumb: x.thumb ?? null }));
      }
      if (json.images) return normalizeList(json.images);
      return [];
    }

    async function fetchImages() {
      galleryGrid.innerHTML = '';
      emptyState.style.display = 'none';
      countLabel.textContent = '';
      // skeletons
      for (let i=0;i<8;i++){ const s = document.createElement('div'); s.className = 'card skeleton'; s.style.height='140px'; galleryGrid.appendChild(s); }
      try {
        const res = await fetch(API.list, { headers: { 'Accept': 'application/json' }});
        const data = await res.json().catch(()=>([]));
        const items = normalizeList(data);
        galleryGrid.innerHTML = '';
        if (!items.length) { emptyState.style.display='flex'; countLabel.textContent = '(0)'; return; }
        countLabel.textContent = `(${items.length})`;
        for (const it of items) {
          const card = document.createElement('div');
          card.className = 'card';
          const img = document.createElement('img');
          img.className = 'thumb'; img.loading = 'lazy'; img.decoding = 'async';
          img.src = '/img/' + encodeURIComponent(it.url); img.alt = it.name || 'image';
          card.appendChild(img);
          const meta = document.createElement('div'); meta.className = 'meta';
          const badge = document.createElement('span'); badge.className='badge'; badge.textContent = it.name || it.id || 'image';
          meta.appendChild(badge);
          if (API.delete) {
            const del = document.createElement('button'); del.className='btn danger'; del.style.padding='6px 10px'; del.textContent='Delete';
            del.onclick = async (e)=>{
              e.stopPropagation();
              if (!confirm('Delete this image from device?')) return;
              try {
                const delUrl = API.delete + encodeURIComponent(it.url);
                const r = await fetch(delUrl, { method:'DELETE' });
                if (!r.ok) throw new Error('Delete failed');
                toast('Deleted');
                fetchImages();
              } catch(err){ toast('Delete error'); console.error(err); }
            };
            meta.appendChild(del);
          }
          card.appendChild(meta);
          card.onclick = ()=> window.open('/img/' + encodeURIComponent(it.url), '_blank');
          galleryGrid.appendChild(card);
        }
      } catch (err) {
        console.error(err);
        galleryGrid.innerHTML = '';
        emptyState.style.display='flex';
        toast('Failed to load images');
      }
    }

    refreshBtn.addEventListener('click', fetchImages);

    // --------- Cropper ---------
    const fileInput = $('#fileInput');
    const dropZone = $('#dropZone');
    const cropCanvas = $('#cropCanvas');
    const ctx = cropCanvas.getContext('2d');
    const zoomRange = $('#zoomRange');
    const outSize = $('#outSize');
    const outSizeLabel = $('#outSizeLabel');
    const uploadBtn = $('#uploadBtn');
    const resetBtn = $('#resetBtn');
    const fileInfo = $('#fileInfo');
    const canvasBox = $('#canvasBox');

  // Settings elements
  const secInput = $('#secInput');
  const saveSettingsBtn = $('#saveSettingsBtn');
  const reloadSettingsBtn = $('#reloadSettingsBtn');
  const settingsInfo = $('#settingsInfo');

    let img = null;
    let scale = 1, minScale = 1, maxScale = 10;
    let offX = 0, offY = 0; // translation in canvas pixels
    let isPanning = false, lastX = 0, lastY = 0;

    function setCanvasToSquareBox() {
      const rect = canvasBox.getBoundingClientRect();
      // ensure backing store matches CSS for crisp drawing
      const side = Math.floor(Math.min(rect.width, rect.height));
      const dpr = window.devicePixelRatio || 1;
      cropCanvas.width = Math.max(600, side) * dpr; // keep high-res drawing even on small screens
      cropCanvas.height = cropCanvas.width; // square viewport
      cropCanvas.style.width = side + 'px';
      cropCanvas.style.height = side + 'px';
      draw();
    }

    window.addEventListener('resize', setCanvasToSquareBox);

    function loadImage(file) {
      return new Promise((resolve, reject)=>{
        const url = URL.createObjectURL(file);
        const image = new Image();
        image.onload = ()=> { URL.revokeObjectURL(url); resolve(image); };
        image.onerror = reject;
        image.src = url;
      });
    }

    function initCropper(image) {
      img = image;
      // Fit image to cover the square viewport
      const cw = cropCanvas.width, ch = cropCanvas.height; // equal
      const sx = cw / img.width; const sy = ch / img.height;
      minScale = Math.max(sx, sy); // cover the square
      scale = minScale; maxScale = minScale * 10;
      offX = 0; offY = 0;
      zoomRange.min = (minScale / minScale).toFixed(3); // 1
      zoomRange.max = (maxScale / minScale).toFixed(3); // 10
      zoomRange.step = 0.001;
      zoomRange.value = (scale / minScale).toFixed(3);
      zoomRange.disabled = false;
      uploadBtn.disabled = false;
      resetBtn.disabled = false;
      draw();
    }

    function draw() {
      const cw = cropCanvas.width, ch = cropCanvas.height; // square
      ctx.clearRect(0,0,cw,ch);
      // fill background
      ctx.fillStyle = '#0b0e13'; ctx.fillRect(0,0,cw,ch);
      if (!img) return;
      ctx.save();
      // move to center then apply current transform
      ctx.translate(cw/2 + offX, ch/2 + offY);
      ctx.scale(scale, scale);
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, -img.width/2, -img.height/2);
      ctx.restore();

      // Overlay: darken outside of the central square (which is the export area)
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.fillRect(0,0,cw,ch);
      // punch out center with destination-out
      ctx.globalCompositeOperation = 'destination-out';
      const m = Math.round(cw * 0.07); // margin just for nicer look
      const side = cw - m*2;
      ctx.fillRect(m, m, side, side);
      ctx.restore();

      // Border for crop area
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.9)';
      ctx.lineWidth = Math.max(2, cw*0.005);
      ctx.setLineDash([8,6]);
      ctx.strokeRect(m+ctx.lineWidth/2, m+ctx.lineWidth/2, side-ctx.lineWidth, side-ctx.lineWidth);
      ctx.restore();
    }

    // Zoom with mouse wheel (cursor-centered zoom)
    cropCanvas.addEventListener('wheel', (e)=>{
      if (!img) return;
      e.preventDefault();
      const rect = cropCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const cx = (e.clientX - rect.left) * dpr; // cursor in canvas pixels
      const cy = (e.clientY - rect.top) * dpr;

      // Translate to canvas-centered space
      const cw = cropCanvas.width, ch = cropCanvas.height;
      const px = cx - cw/2 - offX; // position relative to current origin
      const py = cy - ch/2 - offY;

      const prevScale = scale;
      const zoomIntensity = 1 - (e.deltaY * 0.001);
      scale = Math.max(minScale, Math.min(maxScale, scale * zoomIntensity));

      // Keep point under cursor stable: adjust offset so that (px,py) maps same after scale change
      const ds = scale / prevScale;
      offX -= px * (ds - 1);
      offY -= py * (ds - 1);
      draw();
    }, { passive: false });

    // Pan with mouse / touch (single finger)
    cropCanvas.addEventListener('pointerdown', (e)=>{
      if (!img) return;
      isPanning = true; lastX = e.clientX; lastY = e.clientY; cropCanvas.setPointerCapture(e.pointerId);
    });
    cropCanvas.addEventListener('pointermove', (e)=>{
      if (!img || !isPanning) return;
      const dx = (e.clientX - lastX) * (window.devicePixelRatio || 1);
      const dy = (e.clientY - lastY) * (window.devicePixelRatio || 1);
      lastX = e.clientX; lastY = e.clientY;
      offX += dx; offY += dy; draw();
    });
    const endPan = (e)=>{ isPanning = false; try { cropCanvas.releasePointerCapture(e.pointerId); } catch(_){} };
    cropCanvas.addEventListener('pointerup', endPan);
    cropCanvas.addEventListener('pointercancel', endPan);

    // Basic 2-finger pinch zoom
    let touches = new Map();
    cropCanvas.addEventListener('pointerdown', (e)=>{ touches.set(e.pointerId, {x:e.clientX, y:e.clientY}); });
    cropCanvas.addEventListener('pointerup', (e)=>{ touches.delete(e.pointerId); });
    cropCanvas.addEventListener('pointercancel', (e)=>{ touches.delete(e.pointerId); });
    cropCanvas.addEventListener('pointermove', (e)=>{
      if (!img) return;
      if (touches.size === 2 && touches.has(e.pointerId)) {
        const ids = Array.from(touches.keys());
        touches.set(e.pointerId, {x:e.clientX, y:e.clientY});
        const p0 = touches.get(ids[0]); const p1 = touches.get(ids[1]);
        if (!p0 || !p1) return;
        // previous and current distances
        const prev = Math.hypot((p0.x - lastX), (p0.y - lastY));
        const now = Math.hypot((p0.x - p1.x), (p0.y - p1.y));
        if (prev && now) {
          const rect = cropCanvas.getBoundingClientRect();
          const midX = ((p0.x + p1.x)/2 - rect.left) * (window.devicePixelRatio || 1);
          const midY = ((p0.y + p1.y)/2 - rect.top) * (window.devicePixelRatio || 1);
          const cw = cropCanvas.width, ch = cropCanvas.height;
          const px = midX - cw/2 - offX; const py = midY - ch/2 - offY;
          const prevScale = scale;
          const dsRaw = now / (prev || now);
          const ds = Math.max(0.9, Math.min(1.1, dsRaw)); // dampen
          scale = Math.max(minScale, Math.min(maxScale, scale * ds));
          const k = scale / prevScale; offX -= px * (k - 1); offY -= py * (k - 1);
          draw();
        }
      }
    });

    // UI Controls
    zoomRange.addEventListener('input', ()=>{
      if (!img) return;
      const v = parseFloat(zoomRange.value);
      scale = v * minScale; draw();
    });

    outSize.addEventListener('input', ()=>{ outSizeLabel.textContent = `${outSize.value}×${outSize.value}`; });

    resetBtn.addEventListener('click', ()=>{
      if (!img) return;
      initCropper(img);
    });

    async function handleFiles(files) {
      if (!files || !files.length) return;
      const file = files[0];
      fileInfo.textContent = `${file.name} • ${(file.size/1024/1024).toFixed(2)} MB`;
      try {
        const image = await loadImage(file);
        setCanvasToSquareBox();
        initCropper(image);
      } catch (err) {
        console.error(err); toast('Failed to open image');
      }
    }

    fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));

    dropZone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropZone.style.borderColor = 'var(--accent)'; });
    dropZone.addEventListener('dragleave', ()=>{ dropZone.style.borderColor = 'rgba(255,255,255,.2)'; });
    dropZone.addEventListener('drop', (e)=>{ e.preventDefault(); dropZone.style.borderColor = 'rgba(255,255,255,.2)'; handleFiles(e.dataTransfer.files); });

    // Export cropped square as Blob
    function exportCrop() {
      if (!img) return null;
      const cw = cropCanvas.width, ch = cropCanvas.height; // equal
      // crop box margins as used in draw()
      const m = Math.round(cw * 0.07);
      const side = cw - m*2; // in canvas pixels
      // We need to map this crop square back into the source image coordinates.
      // Current transform: translate(cw/2 + offX, ch/2 + offY), then scale(scale, scale), draw image centered.
      // A point in canvas at (x,y) corresponds in image space to:
      //  p' = ((x - cw/2 - offX)/scale, (y - ch/2 - offY)/scale) + (img.width/2, img.height/2)
      const x0 = m, y0 = m;
      const x1 = m + side, y1 = m + side;
      function toImg(px, py) {
        const ix = ( (px - cw/2 - offX) / scale ) + img.width/2;
        const iy = ( (py - ch/2 - offY) / scale ) + img.height/2;
        return [ix, iy];
      }
      const [ix0, iy0] = toImg(x0, y0);
      const [ix1, iy1] = toImg(x1, y1);
      const sx = Math.max(0, Math.floor(ix0));
      const sy = Math.max(0, Math.floor(iy0));
      const sw = Math.min(img.width - sx, Math.floor(ix1 - ix0));
      const sh = Math.min(img.height - sy, Math.floor(iy1 - iy0));

      const out = document.createElement('canvas');
      const size = parseInt(outSize.value, 10) || 512;
      out.width = size; out.height = size;
      const octx = out.getContext('2d');
      octx.imageSmoothingQuality = 'high';
      octx.drawImage(img, sx, sy, sw, sh, 0, 0, size, size);
      return new Promise(resolve => out.toBlob(resolve, 'image/jpeg', 0.5));
    }

    uploadBtn.addEventListener('click', async ()=>{
      if (!img) return;
      uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading…';
      try {
        const blob = await exportCrop();
        if (!blob) throw new Error('Export failed');
        const filename = `crop_${Date.now()}.jpg`;
        const res = await fetch(API.upload + encodeURIComponent(filename), {
          method: 'PUT',
          body: blob,
          headers: {'Content-Type': 'image/jpeg'}
        });
        if (!res.ok) throw new Error('Upload failed');
        toast('Upload successful');
        fileInput.value = '';
        fileInfo.textContent = '';
        img = null; draw();
        uploadBtn.disabled = true; uploadBtn.textContent = 'Crop & Upload';
        resetBtn.disabled = true; zoomRange.disabled = true;
        fetchImages();
      } catch(err) {
        console.error(err);
        toast(err.message || 'Upload error');
        uploadBtn.disabled = false; uploadBtn.textContent = 'Crop & Upload';
      }
    });

    // Init
    setCanvasToSquareBox();
    fetchImages();

    // --------- Settings ---------
    async function loadSettings() {
      settingsInfo.textContent = 'Loading…';
      try {
        const r = await fetch('/api/settings');
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const js = await r.json();
        const secs = Math.max(1, Math.min(3600, parseInt(js.image_display_seconds||10, 10)));
        secInput.value = String(secs);
        settingsInfo.textContent = 'Synced';
      } catch (e) {
        console.error(e);
        settingsInfo.textContent = 'Failed to load';
        toast('Failed to load settings');
      }
    }

    async function saveSettings() {
      const v = parseInt(secInput.value, 10);
      if (!Number.isFinite(v) || v < 1 || v > 3600) { toast('Enter 1–3600'); return; }
      saveSettingsBtn.disabled = true;
      try {
        const r = await fetch('/api/settings', { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image_display_seconds: v }) });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        toast('Saved');
        settingsInfo.textContent = 'Saved';
      } catch (e) {
        console.error(e);
        toast('Save failed');
        settingsInfo.textContent = 'Save failed';
      } finally {
        saveSettingsBtn.disabled = false;
      }
    }

    reloadSettingsBtn.addEventListener('click', loadSettings);
    saveSettingsBtn.addEventListener('click', saveSettings);
    loadSettings();
  </script>
</body>
</html>
