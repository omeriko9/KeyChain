<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>KeyChain Images</title>
  <style>
    body{font-family:system-ui, Arial, sans-serif; margin:20px;}
    .row{display:flex; gap:12px; flex-wrap:wrap}
    .card{border:1px solid #ddd; border-radius:8px; padding:10px; width:160px}
    .thumb{width:128px; height:128px; object-fit:cover; display:block; margin:auto}
    .muted{color:#666; font-size:12px}
    .bar{display:flex; gap:10px; align-items:center; margin-bottom:16px}
    button{cursor:pointer}
    .crop-wrap{display:none; margin-top:12px}
  canvas{border:1px solid #ccc;}
  </style>
</head>
<body>
  <h1>KeyChain Images</h1>
  <div class="bar">
    <input id="file" type="file" accept="image/jpeg" />
    <button id="btnCrop">Choose square</button>
    <button id="btnUpload">Upload</button>
    <span class="muted">Uploads are resized to 128x128 and JPEG-compressed.</span>
  </div>

  <div class="crop-wrap" id="cropWrap">
    <p class="muted">Drag to select a square. Double-click to confirm crop.</p>
    <canvas id="canvas"></canvas>
  </div>

  <h3>Stored</h3>
  <div class="row" id="list"></div>

  <script>
    const listEl = document.getElementById('list');
    const fileEl = document.getElementById('file');
    const btnUpload = document.getElementById('btnUpload');
    const btnCrop = document.getElementById('btnCrop');
    const cropWrap = document.getElementById('cropWrap');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

  let srcImg = null; // Image element for crop
    let crop = null;   // {x,y,s} in canvas coordinates
    let imgScale = 1;  // scale factor from original to canvas
    let imgOffset = {x:0, y:0}; // offset of image in canvas
    let imgDrawSize = {w:0, h:0}; // scaled size for redrawing
  let backCanvas = null, backCtx = null; // offscreen buffer for scaled image

    async function refreshList(){
      const res = await fetch('/api/list');
      const files = await res.json();
      listEl.innerHTML = '';
      files.forEach(name => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <img class="thumb" src="/img/${encodeURIComponent(name)}" alt="${name}">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
            <span class="muted" title="${name}">${name}</span>
            <button data-name="${name}">Delete</button>
          </div>
        `;
        card.querySelector('button').onclick = async (e)=>{
          const n = e.target.dataset.name;
          if(confirm('Delete '+n+'?')){
            await fetch('/api/delete/'+encodeURIComponent(n), {method:'DELETE'});
            refreshList();
          }
        };
        listEl.appendChild(card);
      });
    }

    function jpegToCanvas(file){
      return new Promise((resolve,reject)=>{
        const fr = new FileReader();
        fr.onload = ()=>{
          const img = new Image();
          img.onload = ()=>resolve(img);
          img.onerror = reject;
          img.src = fr.result;
        };
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    function startCrop(){
      cropWrap.style.display='block';
      // Scale the image so the longest side is at most 512px; keep aspect ratio
      const maxSide = 512;
      const srcLongest = Math.max(srcImg.width, srcImg.height);
      imgScale = Math.min(1, maxSide / srcLongest);
  const w = Math.round(srcImg.width * imgScale);
  const h = Math.round(srcImg.height * imgScale);
  const dpr = window.devicePixelRatio || 1;

  // Prepare offscreen back buffer with the scaled image
  backCanvas = document.createElement('canvas');
  backCanvas.width = Math.round(w * dpr); backCanvas.height = Math.round(h * dpr);
  backCtx = backCanvas.getContext('2d');
  backCtx.clearRect(0, 0, backCanvas.width, backCanvas.height);
  backCtx.drawImage(srcImg, 0, 0, backCanvas.width, backCanvas.height);

  // Make onscreen canvas exactly the scaled image size to avoid any CSS or browser stretching
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';

      // No offset: image fills canvas
      imgOffset.x = 0;
      imgOffset.y = 0;
      imgDrawSize = {w, h};

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(backCanvas, 0, 0, backCanvas.width, backCanvas.height, 0, 0, canvas.width, canvas.height);

      const s = Math.min(w, h) * 0.8;
      crop = {x: (w - s)/2, y: (h - s)/2, s};
      drawCropRect();
    }

    function drawCropRect(){
      if(!crop) return;
      ctx.save();
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(crop.x, crop.y, crop.s, crop.s);
      ctx.restore();
    }

    canvas.addEventListener('mousedown', (e)=>{
      if(!crop) return;
      const r = canvas.getBoundingClientRect();
  const scaleX = (canvas.width / r.width);
  const scaleY = (canvas.height / r.height);
      const sx = (e.clientX - r.left) * scaleX;
      const sy = (e.clientY - r.top) * scaleY;
      crop.drag = {dx:sx-crop.x, dy:sy-crop.y};
    });
    canvas.addEventListener('mousemove', (e)=>{
      if(!crop || !crop.drag) return;
      const r = canvas.getBoundingClientRect();
      const scaleX = canvas.width / r.width;
      const scaleY = canvas.height / r.height;
      const sx = (e.clientX - r.left) * scaleX, sy = (e.clientY - r.top) * scaleY;
  crop.x = sx - crop.drag.dx; crop.y = sy - crop.drag.dy;
  // Constrain crop to image bounds
  const maxX = canvas.width - crop.s;
  const maxY = canvas.height - crop.s;
  if (crop.x < 0) crop.x = 0; else if (crop.x > maxX) crop.x = maxX;
  if (crop.y < 0) crop.y = 0; else if (crop.y > maxY) crop.y = maxY;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(backCanvas, 0, 0, backCanvas.width, backCanvas.height, 0, 0, canvas.width, canvas.height);
      drawCropRect();
    });
    window.addEventListener('mouseup', ()=>{ if(crop) delete crop.drag; });

    canvas.addEventListener('dblclick', ()=>{
      // finalize crop and hide editor
      cropWrap.style.display='none';
    });

    btnCrop.onclick = async ()=>{
      if(!fileEl.files[0]){ alert('Pick a JPEG first'); return; }
      srcImg = await jpegToCanvas(fileEl.files[0]);
      startCrop();
    };

    btnUpload.onclick = async ()=>{
      const f = fileEl.files[0];
      if(!f){ alert('Pick a JPEG first'); return; }
      // render cropped 128x128
      const out = document.createElement('canvas');
      out.width = 128; out.height = 128;
      const octx = out.getContext('2d');

      if(crop){
        // Convert canvas crop coordinates back to original image coordinates (logical pixels)
        const origX = crop.x / imgScale;
        const origY = crop.y / imgScale;
        const origS = crop.s / imgScale;
        octx.drawImage(srcImg, Math.round(origX), Math.round(origY), Math.round(origS), Math.round(origS), 0,0,128,128);
      }else{
        // center-crop square from original image
        const s = Math.min(srcImg.width, srcImg.height);
        const ox = (srcImg.width - s)/2;
        const oy = (srcImg.height - s)/2;
        octx.drawImage(srcImg, ox, oy, s, s, 0,0,128,128);
      }

      const blob = await new Promise(r=> out.toBlob(r, 'image/jpeg', 0.7));
      const name = 'img_'+Date.now()+'.jpg';
      const res = await fetch('/api/upload/' + encodeURIComponent(name), {
        method:'PUT',
        body: blob,
        headers: {'Content-Type': 'image/jpeg'}
      });
      if(!res.ok){ alert('Upload failed'); return; }
      crop = null; srcImg = null; fileEl.value=''; imgScale = 1; imgOffset = {x:0,y:0}; imgDrawSize = {w:0,h:0};
      refreshList();
    };

    refreshList();
  </script>
</body>
</html>
